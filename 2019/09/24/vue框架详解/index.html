<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>深入理解vue | blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="YP's Blog">
  
  <meta name="description" content="vue基础vue-cli脚手架123456789npm install -g @vue/cli或yarn global add @vue/cli创建项目vue create [name]使用图形化界面vue ui  调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象. 基础指令1234567文本插值是最基本的形">
<meta name="keywords" content="web">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解vue">
<meta property="og:url" content="http://localhost:4000/2019/09/24/vue框架详解/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="vue基础vue-cli脚手架123456789npm install -g @vue/cli或yarn global add @vue/cli创建项目vue create [name]使用图形化界面vue ui  调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象. 基础指令1234567文本插值是最基本的形">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.loli.net/2019/09/26/oZsLnaCRl3qQJkM.png">
<meta property="og:image" content="https://i.loli.net/2019/09/26/Bi9arClmjRevOoY.jpg">
<meta property="og:image" content="https://i.loli.net/2019/09/26/jaxvf63mpghXLR5.png">
<meta property="og:image" content="https://i.loli.net/2019/09/26/WSqI6amD3BVx5G8.png">
<meta property="og:image" content="https://i.loli.net/2019/09/26/jBaK4dVUvDIHWPy.png">
<meta property="og:image" content="https://i.loli.net/2019/09/26/C9B2uKNRY8fecvg.png">
<meta property="og:image" content="https://i.loli.net/2019/09/26/DHv8Tj6kUKgMXut.jpg">
<meta property="og:updated_time" content="2020-07-06T06:21:54.629Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解vue">
<meta name="twitter:description" content="vue基础vue-cli脚手架123456789npm install -g @vue/cli或yarn global add @vue/cli创建项目vue create [name]使用图形化界面vue ui  调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象. 基础指令1234567文本插值是最基本的形">
<meta name="twitter:image" content="https://i.loli.net/2019/09/26/oZsLnaCRl3qQJkM.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">YP Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        YP Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个专注 WEB 开发的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Blog" target="_blank" href="https://iloveyou11.github.io/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="https://github.com/iloveyou11">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-vue框架详解" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="post-title" itemprop="name">
      深入理解vue
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/前端/">前端</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-09-24
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

                    
            </header>
            
                <div class="article-entry post-content" itemprop="articleBody">
                    
                            
                                
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue基础"><span class="toc-text">vue基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vue-cli脚手架"><span class="toc-text">vue-cli脚手架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#基础指令"><span class="toc-text">基础指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#class绑定"><span class="toc-text">class绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件修饰符"><span class="toc-text">事件修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nextTick"><span class="toc-text">nextTick</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue-router"><span class="toc-text">vue-router</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vuex"><span class="toc-text">vuex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue生命周期"><span class="toc-text">vue生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue调试方法"><span class="toc-text">vue调试方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue原理"><span class="toc-text">vue原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#组件化思想"><span class="toc-text">组件化思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue响应式原理"><span class="toc-text">vue响应式原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue双向绑定原理"><span class="toc-text">vue双向绑定原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他知识点"><span class="toc-text">其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash模式-和-history模式"><span class="toc-text">hash模式 和 history模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#keep-alive"><span class="toc-text">keep-alive</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#computed-和-watch"><span class="toc-text">computed 和 watch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue项目性能优化"><span class="toc-text">vue项目性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue3-0"><span class="toc-text">vue3.0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#服务器渲染SSR"><span class="toc-text">服务器渲染SSR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#警惕内存泄漏"><span class="toc-text">警惕内存泄漏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#页面过渡动画"><span class="toc-text">页面过渡动画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#可复用的过渡"><span class="toc-text">可复用的过渡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue-router-1"><span class="toc-text">vue-router</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vuex-1"><span class="toc-text">vuex</span></a></li></ol></li></ol>
    </div>
    
                                    <a id="more"></a>



<h4 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h4><h5 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">或</span><br><span class="line">yarn global add @vue/cli</span><br><span class="line"></span><br><span class="line">创建项目</span><br><span class="line">vue create [name]</span><br><span class="line"></span><br><span class="line">使用图形化界面</span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure>

<p>调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象.</p>
<h5 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文本插值是最基本的形式，用双大括号</span><br><span class="line">v-text、v-html</span><br><span class="line">监听事件指令 v-on，简写为@click</span><br><span class="line">属性绑定指令 v-bind，简写为</span><br><span class="line">遍历指令 v-<span class="keyword">for</span></span><br><span class="line">表单输入绑定指令 v-model（<span class="number">3</span>个修饰符.lazy .trim .number）</span><br><span class="line">条件渲染v-<span class="keyword">if</span> 和 v-show的区别、v-<span class="keyword">else</span>-<span class="keyword">if</span> 和 v-<span class="keyword">else</span> 不是必须的</span><br></pre></td></tr></table></figure>

<p><strong>v-if和v-show的区别</strong></p>
<ul>
<li>v-if是真实的条件渲染，当进行条件切换时，它会销毁和重建条件块的内容，并且它支持<template>语法；</template></li>
<li>v-show的条件切换时基于css的display属性，所以不会销毁和重建条件块的内容；</li>
<li>当你频繁需要切换条件时，推荐使用v-show；否则使用v-if；</li>
</ul>
<h5 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.对象语法</span></span><br><span class="line">v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;</span></span><br><span class="line"><span class="string">data: &#123;  </span></span><br><span class="line"><span class="string">isActive: true,</span></span><br><span class="line"><span class="string">  hasError: false</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 2.数组语法</span></span><br><span class="line"><span class="string">&lt;div v-bind:class="</span>[activeClass, errorClass]<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div v-bind:class="</span>[&#123; <span class="attr">active</span>: isActive &#125;, errorClass]<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div v-bind:class="</span>[isActive ? activeClass : <span class="string">''</span>, errorClass]<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">// 3.Style绑定</span></span><br><span class="line"><span class="string">v-bind:style="</span>&#123; <span class="attr">color</span>: activeColor, <span class="attr">fontSize</span>: fontSize + <span class="string">'px'</span> &#125;<span class="string">"</span></span><br></pre></td></tr></table></figure>

<h5 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vue还为v-on提供了事件修饰符</span><br><span class="line">  .stop 阻止事件继续传播</span><br><span class="line">  .prevent 提交的事件不再阻止页面</span><br><span class="line">  .capture 添加事件监听器时使用事件捕获模式</span><br><span class="line">  .self 只当在event.target是当前元素自身时触发处理函数</span><br><span class="line">  .once 点击事件将只触发一次</span><br><span class="line">  .passive 滚动事件的默认行为将会立即触发</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>   &lt;div v-on:click.prevent=<span class="string">"greet"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/div&gt;/</span><span class="regexp">/等价于event.preventDefault()</span></span><br><span class="line"><span class="regexp">2   &lt;div v-on:click.stop="greet"&gt;2&lt;/</span>div&gt;<span class="comment">//等价于event.stopPropagation()</span></span><br><span class="line"><span class="number">3</span>   &lt;div v-on:click.capture=<span class="string">"greet"</span>&gt;<span class="number">3</span>&lt;<span class="regexp">/div&gt;/</span><span class="regexp">/等价于事件回调函数采用捕获阶段监听事件</span></span><br><span class="line"><span class="regexp">4   &lt;div v-on:click.self="greet"&gt;4&lt;/</span>div&gt;<span class="comment">//等价于event.target</span></span><br></pre></td></tr></table></figure>

<h5 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h5><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br>需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。<br><img src="https://i.loli.net/2019/09/26/oZsLnaCRl3qQJkM.png" alt="nextTick.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样可以，nextTick里面的代码会在DOM更新后执行</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">//可以得到'changed'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</span></span><br><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h5><p><a href="http://www.imooc.com/article/70052" target="_blank" rel="noopener">Vue2.0之vue-router</a></p>
<p><a href="https://www.cnblogs.com/keepfool/p/5690366.html" target="_blank" rel="noopener">vue-router 60分钟快速入门</a></p>
<p>安装vue-router</p>
<p>几种实现方式动态路由匹配、嵌套路由、编程式路由、命名路由<br>命名视图、重定向与别名、路由组件传参</p>
<p><strong>导航护卫</strong></p>
<p><strong>全局前置守卫</strong>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。</p>
<p><strong>全局解析守卫</strong>这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>
<p><strong>全局后置钩子</strong><br>transition 可以定义路由过渡动画</p>
<h5 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h5><p><code>npm install vuex –save</code></p>
<ol>
<li><strong>state</strong>：定义全局状态属性<br>this.$store.state.showFooter</li>
<li><strong>getters</strong>：和vue计算属性computed一样，来实时监听state值的变化(最新状态)，并把它也仍进Vuex.Store里面</li>
<li><strong>mutations</strong>：具体的用法就是给里面的方法传入参数state或额外的参数,然后利用vue的双向数据驱动进行值的改变，同样的定义好之后也把这个mutations扔进Vuex.Store里面<br>this.$store.commit(‘show’)</li>
<li><strong>actions</strong>：通常用于异步操作或是mutations的封装，可以包含任意异步操作，这里面的方法是用来异步触发mutations里面的方法，actions里面自定义的函数接收一个context参数和要变化的形参，context与store实例具有相同的方法和属性，所以它可以执行context.commit(‘ ‘),然后也不要忘了把它也扔进Vuex.Store里面<br>this.$store.dispatch(‘showFooter’)</li>
</ol>
<p>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"> <span class="keyword">const</span> state=&#123;   <span class="comment">//要设置的全局访问的state对象</span></span><br><span class="line">     showFooter: <span class="literal">true</span>,</span><br><span class="line">     changableNum:<span class="number">0</span></span><br><span class="line">     <span class="comment">//要设置的初始属性值</span></span><br><span class="line">   &#125;;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;   <span class="comment">//实时监听state值的变化(最新状态)</span></span><br><span class="line">    isShow(state) &#123;  <span class="comment">//承载变化的showFooter的值</span></span><br><span class="line">       <span class="keyword">return</span> state.showFooter</span><br><span class="line">    &#125;,</span><br><span class="line">    getChangedNum()&#123;  <span class="comment">//承载变化的changebleNum的值</span></span><br><span class="line">       <span class="keyword">return</span> state.changableNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    show(state) &#123;   <span class="comment">//自定义改变state初始值的方法，这里面的参数除了state之外还可以再传额外的参数(变量或对象);</span></span><br><span class="line">        state.showFooter = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    hide(state) &#123;  <span class="comment">//同上</span></span><br><span class="line">        state.showFooter = <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    newNum(state,sum)&#123; <span class="comment">//同上，这里面的参数除了state之外还传了需要增加的值sum</span></span><br><span class="line">       state.changableNum+=sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">const</span> actions = &#123;</span><br><span class="line">    hideFooter(context) &#123;  <span class="comment">//自定义触发mutations里函数的方法，context与store 实例具有相同方法和属性</span></span><br><span class="line">        context.commit(<span class="string">'hide'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    showFooter(context) &#123;  <span class="comment">//同上注释</span></span><br><span class="line">        context.commit(<span class="string">'show'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getNewNum(context,num)&#123;   <span class="comment">//同上注释，num为要变化的形参</span></span><br><span class="line">        context.commit(<span class="string">'newNum'</span>,num)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">       state,</span><br><span class="line">       getters,</span><br><span class="line">       mutations,</span><br><span class="line">       actions</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>modules 模块化 以及 组件中引入 mapGetters、mapActions 和 mapStates的使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState,mapGetters,mapActions&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line">computed:&#123;</span><br><span class="line">    	...mapState(&#123;  <span class="comment">//这里的...是超引用，ES6的语法，意思是state里有多少属性值我可以在这里放多少属性值</span></span><br><span class="line">         isShow:<span class="function"><span class="params">state</span>=&gt;</span>state.footerStatus.showFooter <span class="comment">//注意这些与上面的区别就是state.footerStatus,</span></span><br><span class="line">      &#125;),</span><br><span class="line">...mapActions(<span class="string">'collection'</span>,[ <span class="comment">//collection是指modules文件夹下的collection.js</span></span><br><span class="line">          <span class="string">'invokePushItems'</span>  <span class="comment">//collection.js文件中的actions里的方法，在上面的@click中执行并传入实参</span></span><br><span class="line">      ])，</span><br><span class="line">...mapGetters(<span class="string">'collection'</span>,&#123; <span class="comment">//用mapGetters来获取collection.js里面的getters</span></span><br><span class="line">            arrList:<span class="string">'renderCollects'</span></span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h5><p>vue生命周期:Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<p>总共分为 8 个阶段beforeCreate（创建前） created（创建后） beforeMount（载入前） mounted（载入后） beforeUpdate（更新前）, updated（更新后） beforeDestroy（销毁前） destroyed（销毁后）。</p>
<ul>
<li>创建前/后：在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。</li>
<li>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</li>
<li>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</li>
<li>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。</li>
<li>另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated钩子函数。</li>
</ul>
<p><strong>应用场景？</strong></p>
<ul>
<li>beforeCreate 可以在此时加一些loading效果，在created时进行移除</li>
<li>created 需要异步请求数据的方法可以在此时执行，完成数据的初始化</li>
<li>mounted 当需要操作dom的时候执行，可以配合$.nextTick 使用进行单一事件对数据的更新后更新dom</li>
<li>updated 当数据更新需要做统一业务处理的时候使用</li>
</ul>
<h5 id="vue调试方法"><a href="#vue调试方法" class="headerlink" title="vue调试方法"></a>vue调试方法</h5><ol>
<li><a href="https://cn.vuejs.org/v2/cookbook/debugging-in-vscode.html" target="_blank" rel="noopener">在 VS Code 中调试</a></li>
</ol>
<p>vscode安装Debugger for Chrome。在vue.config.js中设置source-map：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    devtool: <span class="string">'source-map'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击“调试”&gt;“添加配置”，生成launch.json，注意url的端口要与项目运行的端口一致，点击“开始调试”即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="string">"configurations"</span>: [&#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"chrome"</span>,</span><br><span class="line">    <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"vuejs: chrome"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://localhost:8081"</span>,</span><br><span class="line">    <span class="string">"webRoot"</span>: <span class="string">"$&#123;workspaceFolder&#125;/src"</span>,</span><br><span class="line">    <span class="string">"breakOnLoad"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"sourceMapPathOverrides"</span>: &#123;</span><br><span class="line">      <span class="string">"webpack:///./src/*"</span>: <span class="string">"$&#123;webRoot&#125;/*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://cn.vuejs.org/v2/cookbook/debugging-in-vscode.html#Vue-Devtools" target="_blank" rel="noopener">Vue DevTools</a></li>
</ol>
<p>直接在chrome中下载此插件即可。</p>
<p><strong>对于Vue-cli创建的工程化项目，哪些方式可以调试应用？</strong></p>
<ul>
<li>使用vue官方推荐的devTools进行调试（官方推荐的dev-Tools是最方便去查看vue的状态管理、vue变量的工具）</li>
<li>在webpack配置代码中打开source-map，插入debugger，使用chrome的调试窗口（但是要注意这种方式，不方便查看vuex的状态变化，vuex的commit事件无法监听）</li>
<li>使用alert, console.log，JSON.stringfy打印相关的日志（这个是最大众，最简单，也是最普通的一种方式了）</li>
</ul>
<h4 id="vue原理"><a href="#vue原理" class="headerlink" title="vue原理"></a>vue原理</h4><h5 id="组件化思想"><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h5><p><strong>组件化</strong>是将页面的功能模块进行拆分、封装，组件代码包含了组件所有的功能代码与样式。<br><strong>组件化的作用</strong>是复用、高可维护性。<br>组件化不局限于前端代码，而是一种设计思想。</p>
<h5 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h5><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">官方解释</a></p>
<p>如何追踪数据变化？</p>
<p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。</p>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。</p>
<p>以下是官方的流程图:<br><img alt="vue响应式原理" src="https://i.loli.net/2019/09/26/Bi9arClmjRevOoY.jpg" width="60%"><br>由上图可知，每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖（借用getter实现）。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<h5 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h5><p>vue实现数据双向绑定主要是：采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过 <strong>Object.defineProperty（）</strong> 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。</p>
<p>当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。<br><img alt="vue双向绑定" src="https://i.loli.net/2019/09/26/jaxvf63mpghXLR5.png" width="60%"><br><img alt="vue双向绑定" src="https://i.loli.net/2019/09/26/WSqI6amD3BVx5G8.png" width="60%"><br>veu2.0使用Object.defineProperty存在一些缺陷，vue3.0改为使用proxy实现双向数据绑定。</p>
<p><strong>如何正确地更新页面列表list中第2个元素？</strong></p>
<p>由于 JavaScript 的限制，Vue 不能检测以下数组的变动：</p>
<ul>
<li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li>
<li>当你修改数组的长度时，例如：vm.items.length = newLength</li>
</ul>
<p>所以，不能采用在Vue的实例中，this.lists[1] = data，或是在数据请求的回调中，使用vm.lists[1] = data。</p>
<p>解决方案：</p>
<ul>
<li>在数据请求的回调中，使用$set方法，Vue.$set(vm.lists, 1, data) <a href="https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">对应API</a></li>
<li>new一个新的数组listsNew，然后把第二个元素改成data，然后把this.lists = listsNew，赋值给数组。</li>
</ul>
<h4 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h4><h5 id="hash模式-和-history模式"><a href="#hash模式-和-history模式" class="headerlink" title="hash模式 和 history模式"></a>hash模式 和 history模式</h5><p><strong>hash模式</strong>：<br>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取</p>
<p><strong>特点：</strong> hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回" target="_blank" rel="noopener">http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</p>
<p><strong>history模式</strong>：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <code>http://www.xxx.com/items/id</code>。 后端如果缺少对 /items/id 的路由处理，将返回 404 错误。</p>
<p><strong>特点</strong>：Vue-Router 官网里如此描述“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p>
<h5 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h5><p>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) </p>
<h5 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h5><p><strong>computed</strong>： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p><strong>watch</strong>： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p>运用场景：</p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h5 id="vue项目性能优化"><a href="#vue项目性能优化" class="headerlink" title="vue项目性能优化"></a>vue项目性能优化</h5><p><strong>（1）代码层面的优化</strong></p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<p><strong>（2）Webpack 层面的优化</strong></p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<p><strong>（3）基础的 Web 技术的优化</strong></p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h5 id="vue3-0"><a href="#vue3-0" class="headerlink" title="vue3.0"></a>vue3.0</h5><p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p>
<p><strong>（1）监测机制的改变</strong></p>
<p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p>
<ul>
<li>只能监测属性，不能监测对象</li>
<li>检测属性的添加和删除；</li>
<li>检测数组索引和长度的变更；</li>
<li>支持 Map、Set、WeakMap 和 WeakSet。<br>新的 observer 还提供了以下特性：</li>
<li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li>
<li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li>
<li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li>
<li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li>
<li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li>
</ul>
<p><strong>（2）模板</strong></p>
<p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。<br>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p>
<p><strong>（3）对象式的组件声明方式</strong></p>
<p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p>
<p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p>
<p><strong>（4）其它方面的更改</strong></p>
<p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p>
<ul>
<li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>基于 treeshaking 优化，提供了更多的内置功能。</li>
</ul>
<p><strong>vue应用</strong></p>
<p><strong>父子组件通信中常用方法</strong></p>
<ol>
<li>在父组件中，使用component引用子组件，然后使用props属性：<br><code>&lt;child-component :property=&quot;data&quot;&gt;&lt;/child-component&gt;</code></li>
<li>使用Vuex状态管理进行父子组件通信，定义store.js，并定义state，在state中定义传递的属性比如叫childProperty。然后，在子组件中，使用<code>store.state.childProperty</code>进行使用。</li>
<li>使用router中的Params进行传参（即路径传参）,<br>设置路由<code>/child/:id</code>，当访问到/child/1元素的时候，在子组件中，使用<code>this.$route.params.id</code>的方式进行使用</li>
</ol>
<p>++不推荐使用LocalStorage缓存传参++，虽然使用缓存也可以获取到数据。但是，这不是推荐的做法，也不方便管理，容易丢失数据或者是数据紊乱（因为没有及时清理与回收）</p>
<p><strong>vue-cli与elementui集成</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装element</span></span><br><span class="line">vue add element</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js引入element</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现按需引入</span></span><br><span class="line">npm install babel-plugin-component -D</span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.component(Button.name, Button);</span><br><span class="line">Vue.component(Select.name, Select);</span><br><span class="line"><span class="comment">/* 或写为</span></span><br><span class="line"><span class="comment"> * Vue.use(Button)</span></span><br><span class="line"><span class="comment"> * Vue.use(Select)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="服务器渲染SSR"><a href="#服务器渲染SSR" class="headerlink" title="服务器渲染SSR"></a>服务器渲染SSR</h5><p><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">Vue SSR指南</a></p>
<p><a href="https://segmentfault.com/a/1190000009352740" target="_blank" rel="noopener">从零开始搭建vue-ssr系列</a></p>
<p><strong>nuxt.js</strong><br><a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener">官网</a><br><a href="https://iiong.com/nuxtjs-notes/" target="_blank" rel="noopener">学习笔记</a><br><a href="https://www.bilibili.com/video/av37607677/?p=7" target="_blank" rel="noopener">视频教程</a></p>
<p>客户端渲染和服务器端渲染的最重要的区别就是究竟是谁来完成html文件的完整拼接，如果是在服务器端完成的，然后返回给客户端，就是服务器端渲染，而如果是前端做了更多的工作完成了html的拼接，则就是客户端渲染<br>。<br>创建nuxt项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn create nuxt-app &lt;项目名&gt;</span><br><span class="line">yarn install</span><br><span class="line">cnpm run dev</span><br><span class="line"><span class="comment">// 如果要使用 sass 就必须要安装 node-sass和sass-loader</span></span><br><span class="line">npm install --save-dev node-sass sass-loader</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2019/09/26/jBaK4dVUvDIHWPy.png" width="60%" alt="nuxt">

<p><a href="http://www.imooc.com/article/72021" target="_blank" rel="noopener">相关文章</a></p>
<p>前端vue等框架打包的项目一般为SPA应用，而单页面是不利于SEO的，现在的解决方案有两种：</p>
<ul>
<li>SSR服务器渲染</li>
<li>预渲染模式(这比服务端渲染要简单很多，而且可以配合 vue-meta-info 来生成title和meta标签，基本可以满足SEO的需求 )
　  </li>
</ul>
<p><strong>TIPS</strong> : 使用预渲染vue-router必须使用history模式。当然，有时候我们也可能会遇到让人头疼的SEO问题，那么使用此插件配合 prerender-spa-plugin 也是再合适不过了<br><img src="https://i.loli.net/2019/09/26/C9B2uKNRY8fecvg.png" width="50%" alt="nuxt流程图"><br><a href="https://blog.csdn.net/aeoliancrazy/article/details/79539143" target="_blank" rel="noopener">Vue SEO处理1——Vue-meta-info&amp;prerender-spa-plugin</a></p>
<h5 id="警惕内存泄漏"><a href="#警惕内存泄漏" class="headerlink" title="警惕内存泄漏"></a>警惕内存泄漏</h5><ul>
<li>beforeDestroy()、destroyed钩子清除出定时器、相关变量置为null</li>
<li>使用内建的 keep-alive组件，状态就会保留，因此就留在了内存里</li>
</ul>
<p>要确保测试应用的内存泄漏问题并在适当的时机做必要的组件清理。</p>
<h5 id="页面过渡动画"><a href="#页面过渡动画" class="headerlink" title="页面过渡动画"></a>页面过渡动画</h5><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p>
<ul>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
</ul>
<p>Vue 提供了 transition的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>
<ul>
<li>条件渲染 (使用 v-if)</li>
<li>条件展示 (使用 v-show)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>在进入/离开的过渡中，会有 6 个 class 切换。<br><img src="https://i.loli.net/2019/09/26/DHv8Tj6kUKgMXut.jpg" alt="vue页面过渡" width="60%"><br>对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。</p>
<h5 id="可复用的过渡"><a href="#可复用的过渡" class="headerlink" title="可复用的过渡"></a>可复用的过渡</h5><p>过渡可以通过 Vue的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <transition> 或者 <transition-group> 作为根组件，然后将任何子组件放置在其中就可以了。</transition-group></transition></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-special-transition'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;transition\</span></span><br><span class="line"><span class="string">      name="very-special-transition"\</span></span><br><span class="line"><span class="string">      mode="out-in"\</span></span><br><span class="line"><span class="string">      v-on:before-enter="beforeEnter"\</span></span><br><span class="line"><span class="string">      v-on:after-enter="afterEnter"\</span></span><br><span class="line"><span class="string">    &gt;\</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;\</span></span><br><span class="line"><span class="string">    &lt;/transition&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="vue-router-1"><a href="#vue-router-1" class="headerlink" title="vue-router"></a>vue-router</h5><p><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vue-router</a></p>
<h5 id="vuex-1"><a href="#vuex-1" class="headerlink" title="vuex"></a>vuex</h5><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex</a></p>

                                        
                </div>
                <footer class="article-footer">
                    
                        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://localhost:4000/2019/09/24/vue框架详解/&title=《深入理解vue》 — blog&pic=/images/banner.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://localhost:4000/2019/09/24/vue框架详解/&title=《深入理解vue》 — blog&source=一个专注web开发技术的网站" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2019/09/24/vue框架详解/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《深入理解vue》 — blog&url=http://localhost:4000/2019/09/24/vue框架详解/&via=http://localhost:4000" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://localhost:4000/2019/09/24/vue框架详解/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://localhost:4000/2019/09/24/vue框架详解/" alt="微信分享二维码">
</div>

<div class="mask"></div>

                            
                                <ul class="article-footer-menu">
                                    
                                            
                                </ul>
                                
                </footer>
    </div>
</article>

    
    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vue基础"><span class="post-toc-text">vue基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue-cli脚手架"><span class="post-toc-text">vue-cli脚手架</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#基础指令"><span class="post-toc-text">基础指令</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#class绑定"><span class="post-toc-text">class绑定</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#事件修饰符"><span class="post-toc-text">事件修饰符</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#nextTick"><span class="post-toc-text">nextTick</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue-router"><span class="post-toc-text">vue-router</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vuex"><span class="post-toc-text">vuex</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue生命周期"><span class="post-toc-text">vue生命周期</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue调试方法"><span class="post-toc-text">vue调试方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#vue原理"><span class="post-toc-text">vue原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#组件化思想"><span class="post-toc-text">组件化思想</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue响应式原理"><span class="post-toc-text">vue响应式原理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue双向绑定原理"><span class="post-toc-text">vue双向绑定原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#其他知识点"><span class="post-toc-text">其他知识点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#hash模式-和-history模式"><span class="post-toc-text">hash模式 和 history模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#keep-alive"><span class="post-toc-text">keep-alive</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#computed-和-watch"><span class="post-toc-text">computed 和 watch</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue项目性能优化"><span class="post-toc-text">vue项目性能优化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue3-0"><span class="post-toc-text">vue3.0</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#服务器渲染SSR"><span class="post-toc-text">服务器渲染SSR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#警惕内存泄漏"><span class="post-toc-text">警惕内存泄漏</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#页面过渡动画"><span class="post-toc-text">页面过渡动画</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#可复用的过渡"><span class="post-toc-text">可复用的过渡</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vue-router-1"><span class="post-toc-text">vue-router</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#vuex-1"><span class="post-toc-text">vuex</span></a></li></ol></li></ol>
        </nav>
    </aside>
    
        
<nav id="article-nav">
  
    <a href="/2019/09/25/react框架详解/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          深入理解react
        
      </span>
    </a>
  
  
    <a href="/2019/09/22/linux与docker实践/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">linux与docker实践</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>

            
                
                    
                                                    </section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 Yang Pei<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
    var mihoConfig = {
        root: "http://localhost:4000",
        animate: "false" ,
        isHome: "false" ,
        share: "true"
    }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/AI/">AI</a><a class="category-link" href="/categories/前端/">前端</a><a class="category-link" href="/categories/计算机/">计算机</a><a class="category-link" href="/categories/语言/">语言</a>
        </div>
        <div id="sidebar-menu-box-tags">
            
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            
        </div>
    </div>
</div>
    <div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
    <script src="/js/search.js"></script>
        <script src="/js/main.js"></script>

            
                <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
                <div id="particles"></div>
                <script src="/js/particles.js"></script>
                    

                        

                                

                                                
                                                                
                                                                    <script src="/js/pop-img.js"></script>
                                                                        <script>
                                                                            $(".article-entry p img").popImg();
                                                                        </script>
                                                                        
  </div>
</body>
</html>