<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><link rel="stylesheet" href="/js/fancybox/dist/jquery.fancybox.min.css"><title>剑指offer笔记 | blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="YP's Blog"><meta name="description" content="1 在一个二维数组中（每个一维数组的长度相同）,每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"><meta name="keywords" content="web"><meta property="og:type" content="article"><meta property="og:title" content="剑指offer笔记"><meta property="og:url" content="http://localhost:4000/2019/04/08/剑指offer/index.html"><meta property="og:site_name" content="blog"><meta property="og:description" content="1 在一个二维数组中（每个一维数组的长度相同）,每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2020-07-04T05:55:52.991Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="剑指offer笔记"><meta name="twitter:description" content="1 在一个二维数组中（每个一维数组的长度相同）,每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"><link rel="icon" href="/favicon.ico"><link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"><script src="/js/pace.min.js"></script></head><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script src="/js/fancybox/dist/jquery.fancybox.min.js"></script><script src="/js/wrapimg.js"></script></html><body><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">YP&#39;s Blog</span></a><nav id="header-menu-nav" class="right"><a href="/"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/categories/前端/"><i class="fa fa-前端"></i> <span>前端</span> </a><a href="/categories/源码/"><i class="fa fa-源码"></i> <span>源码</span> </a><a href="/categories/ML/"><i class="fa fa-ML"></i> <span>ML</span> </a><a href="/categories/CV/"><i class="fa fa-CV"></i> <span>CV</span> </a><a href="/categories/NLP/"><i class="fa fa-NLP"></i> <span>NLP</span> </a><a href="/categories/计算机/"><i class="fa fa-计算机"></i> <span>计算机</span> </a><a href="/categories/专题/"><i class="fa fa-专题"></i> <span>专题</span> </a><a href="/categories/感想/"><i class="fa fa-感想"></i> <span>感想</span> </a><a href="/categories/语言/"><i class="fa fa-语言"></i> <span>语言</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>YP&#39;s Blog</h2></div><div id="header-description"><h3>一个专注前端智能化领域的技术博客</h3></div></div><nav class="header-nav"><div class="social"><a title="Blog" target="_blank" href="https://iloveyou11.github.io/"><i class="fa fa-home fa-2x"></i></a> <a title="Github" target="_blank" href="https://github.com/iloveyou11"><i class="fa fa-github fa-2x"></i></a></div></nav></div></div></header><div class="outer"><section id="main" class="body-wrap"><article id="post-剑指offer" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">剑指offer笔记</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/计算机/">计算机</a></li><li><i class="fa fa-calendar"></i> 2019-04-08</li></ul></div><div style="margin-top:10px"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i> <span class="post-meta-item-text">字数统计: </span><span class="post-count">11.8k字</span> </span></span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i> <span class="post-meta-item-text">阅读时长: </span><span class="post-count">55分</span></span></span></div></header><div class="article-entry post-content" itemprop="articleBody"><div id="toc"></div><p><strong>1 在一个二维数组中（每个一维数组的长度相同）,每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rowCount = array.length</span><br><span class="line">    <span class="keyword">let</span> colCount = array[<span class="number">0</span>].length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = rowCount - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; colCount;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target === array[i][j]) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt; array[i][j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i--</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy,则经过替换之后的字符串为We%20Are%20Happy。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/\s/g</span></span><br><span class="line">    <span class="keyword">return</span> str.replace(reg, <span class="string">'%20'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用空间换时间</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newStr = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] === <span class="string">' '</span>) &#123;</span><br><span class="line">            newStr += <span class="string">'%20'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newStr += str[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>节约空间，直接操作原字符串，倒序插入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace3</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先统计空格总数，确定最后一个字符的位置</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> strArr = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strArr[i] === <span class="string">' '</span>) count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，要将字符串转化为数组之后才能进行从后往前扩展赋值的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = strArr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strArr[i] !== <span class="string">' '</span>)</span><br><span class="line">            strArr[i + <span class="number">2</span> * count] = strArr[i]</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            count--</span><br><span class="line">            strArr[i + <span class="number">2</span> * count] = <span class="string">'%'</span></span><br><span class="line">            strArr[i + <span class="number">2</span> * count + <span class="number">1</span>] = <span class="string">'2'</span></span><br><span class="line">            strArr[i + <span class="number">2</span> * count + <span class="number">2</span>] = <span class="string">'0'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strArr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(replaceSpace3('hello world'));</span></span><br></pre></td></tr></table></figure><p><strong>3 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</strong></p><p><strong>方法1：使用尾递归</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead1</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="keyword">let</span> node = head</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            list = printListFromTailToHead(node.next)</span><br><span class="line">        &#125;</span><br><span class="line">        list.push(node.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：使用栈</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead2</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="keyword">let</span> node = head</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        list.unshift(node.val) **先把首节点放进去</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.next</span><br><span class="line">            list.unshift(node.val) **依次放入下一个节点值</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(val, next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> node4 = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">let</span> node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, node4)</span><br><span class="line"><span class="keyword">let</span> node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, node3)</span><br><span class="line"><span class="keyword">let</span> node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, node2)</span><br><span class="line"><span class="comment">//console.log(printListFromTailToHead2(node1));</span></span><br></pre></td></tr></table></figure><p><strong>4 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</strong></p><p>先序遍历特点：第一个值是根节点<br>中序遍历特点：根节点左边都是左子树，右边都是右子树<br>思路：<br>首先根据根节点a将中序遍历划分为两部分，左边为左子树，右边为右子树<br>在左子树中根据第一条规则递归，得出左子树<br>在右子树中根据第一条规则递归，得出右子树<br>最后合成一棵树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reConstructBinaryTree</span>(<span class="params">pre, vin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre.length == <span class="number">0</span> || vin.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    let index = vin.indexOf(pre[0]) ##根节点在vin的索引</span><br><span class="line">    let left = vin.slice(0, index) ##中序左子树</span><br><span class="line">    let right = vin.slice(index + 1) ##中序右子树</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        val: pre[<span class="number">0</span>],</span><br><span class="line">        left: reConstructBinaryTree(pre.slice(<span class="number">1</span>, index + <span class="number">1</span>), left),</span><br><span class="line">        right: reConstructBinaryTree(pre.slice(index + <span class="number">1</span>), right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</strong></p><p>分析：<br>入队：将元素进栈A<br>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；<br>如果不为空，栈B直接出栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inStack = [],</span><br><span class="line">    outStack = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    inStack.push(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inStack.length === <span class="number">0</span> &amp;&amp; outStack.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!outStack.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (inStack.length) &#123;</span><br><span class="line">            outStack.push(inStack.pop())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p><p><strong>方法1：直接找出数组最小值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minNumberInRotateArray</span>(<span class="params">rotateArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rotateArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> min = rotateArray[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> rotateArray) &#123;</span><br><span class="line">        min = i &lt; min ? i : min</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：直接找出开始非递增的值. 非减排序数组的旋转数组，遍历找到第一个小于前一个数的值即为最小值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minNumberInRotateArray</span>(<span class="params">rotateArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rotateArray.length) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rotateArray.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rotateArray[i] &lt; rotateArray[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> rotateArray[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法3：二分查找，根据中间值进行判断</strong><br>中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。<br>移动之后，第一个指针仍然位于前面的递增数组中。<br>中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minNumberInRotateArray</span>(<span class="params">rotateArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> size = rotateArray.length</span><br><span class="line">    <span class="keyword">if</span> (size === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        **定义left指针、right指针</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="number">0</span></span><br><span class="line">        **确保是旋转数组</span><br><span class="line">    <span class="keyword">while</span> (rotateArray[left] &gt; rotateArray[right]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left === <span class="number">1</span>) &#123;</span><br><span class="line">            mid = right</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        **这里注意要将小数化为整数，否则mid为小数，导致后面结果均为<span class="literal">undefined</span></span><br><span class="line">        mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>)</span><br><span class="line">            **如果rotateArray[left] rotateArray[right] rotateArray[mid]三者相等</span><br><span class="line">            **无法确定中间元素是属于前面还是后面的递增子数组</span><br><span class="line">            **只能顺序查找</span><br><span class="line">        <span class="keyword">if</span> (rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> _MinOrder(rotateArray, left, right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[mid] &gt; rotateArray[left]) &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[mid]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_MinOrder</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> min = array[left]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">            min = array[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let arr = [4, 5, 6, 7, 2, 3]</span></span><br><span class="line"><span class="comment">// console.log(minNumberInRotateArray(arr));</span></span><br></pre></td></tr></table></figure><p><strong>7 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</strong><br><strong>方法1：正向相加，以下两种写法是一样的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">1</span>,</span><br><span class="line">        n2 = <span class="number">1</span>,</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res = n1 + n2</span><br><span class="line">        n1 = n2</span><br><span class="line">        n2 = res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">0</span>,</span><br><span class="line">        n2 = <span class="number">1</span>,</span><br><span class="line">        res</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = n1 + n2</span><br><span class="line">        n1 = n2</span><br><span class="line">        n2 = res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：使用递归（速度太慢，占用大量内存，不建议使用）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</strong><br>分析：同样是斐波拉契数列，但是与上述的斐波拉契数列不同<br>上面的为 0 | 1 1 2 3 5 ……<br>本题的为 0 | 1 2 3 5 8 ……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloor</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (number === <span class="number">1</span> || number === <span class="number">2</span>) <span class="keyword">return</span> number</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">1</span>,</span><br><span class="line">        n2 = <span class="number">2</span>,</span><br><span class="line">        res</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; number; i++) &#123;</span><br><span class="line">        res = n1 + n2</span><br><span class="line">        n1 = n2</span><br><span class="line">        n2 = res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong><br>分析：f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(1) =f(n-1)+f(n-1)=2*f(n-1)<br>数列类似于1 2 4 8 16……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloorII</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (number === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * jumpFloorII(number - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用递归</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloorII</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (number === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;</span><br><span class="line">        res = <span class="number">2</span> * res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用位运算，报错：未通过所有的测试用例，why？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloorII</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res &lt;&lt; (number - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</strong><br><strong>普通计算</strong><br>‘&gt;&gt;&gt;’是无视符号位的右移，&gt;&gt;右移是补符号位，所以负数补1造成死循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    if (n &lt; 0) n = n &gt;&gt;&gt; 0 ##计算补码</span><br><span class="line">    <span class="keyword">let</span> res = n.toString(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res[i] === <span class="string">'1'</span>) count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用位运算符计算</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">        count++ **如果一个整数不为<span class="number">0</span>，那么这个整数至少有一位是<span class="number">1</span></span><br><span class="line">        n = n &amp; (n - 1) ##将二进制的最后一个1变为0</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</strong><br><strong>传统公式求解时间复杂度O(n)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Power</span>(<span class="params">base, exponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.abs(exponent); i++) &#123;</span><br><span class="line">        result *= base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) result = <span class="number">1</span> / result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归，事件复杂度O(logn)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Power</span>(<span class="params">base, exponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">Math</span>.abs(exponent)</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span> &amp;&amp; base !== <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> base</span><br><span class="line">    <span class="keyword">let</span> result = Power(base, n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    result *= result</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) === <span class="number">1</span>) result *= base</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) result = <span class="number">1</span> / result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>综合解法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Power</span>(<span class="params">base, exponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span> &amp;&amp; base != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">0</span> &amp;&amp; exponent &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">0</span> &amp;&amp; exponent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> n = exponent;</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = -exponent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = Power(base, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    result *= result;</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        result *= base;</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>)</span><br><span class="line">        result = <span class="number">1</span> / result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。 并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p><p><strong>方法1：另开空间</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reOrderArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> odds = [],</span><br><span class="line">        evens = []</span><br><span class="line">    array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            evens.push(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            odds.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> odds.concat(evens)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用插入排序，不正确</span></span><br><span class="line"><span class="comment">// function reOrderArray2(array) &#123;</span></span><br><span class="line"><span class="comment">//     for (let i = 1; i &lt; array.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//         if (array[i] % 2 == 1) &#123;</span></span><br><span class="line"><span class="comment">//             for (let j = i; j &gt; 0; j--) &#123;</span></span><br><span class="line"><span class="comment">//                 if (array[j - 1] % 2 == 0) &#123;</span></span><br><span class="line"><span class="comment">//                     let temp = array[j];</span></span><br><span class="line"><span class="comment">//                     array[j] = array[j - 1];</span></span><br><span class="line"><span class="comment">//                     array[j - 1] = temp;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>13 输入一个链表，输出该链表中倒数第k个结点。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><p>分析：定义两个指针快指针和慢指针，让快指针先走(k-1)步<br>再让快指针和慢指针同时走，快指针走完时，慢指针就到达了倒数第k个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> fastNode = head,</span><br><span class="line">        slowNode = head</span><br><span class="line">        **注意这里是先走k<span class="number">-1</span>步</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fastNode.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        fastNode = fastNode.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fastNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fastNode = fastNode.next</span><br><span class="line">        slowNode = slowNode.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>14 输入一个链表，反转链表后，输出新链表的表头。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseList</span>(<span class="params">pHead</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>,</span><br><span class="line">        next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span></span><br><span class="line">        <span class="comment">//如此就可以做到反转链表的效果</span></span><br><span class="line">        <span class="comment">//先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span></span><br><span class="line">        next = head.next;</span><br><span class="line">        <span class="comment">//保存完next，就可以让head从指向next变成指向pre了，代码如下</span></span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="comment">//head指向pre后，就继续依次反转下一个节点</span></span><br><span class="line">        <span class="comment">//让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span></span><br><span class="line"></span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>15 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong><br><strong>方法1：采用递归版本</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Merge</span>(<span class="params">pHead1, pHead2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead1 == <span class="literal">null</span>) <span class="keyword">return</span> pHead2</span><br><span class="line">    <span class="keyword">if</span> (pHead2 == <span class="literal">null</span>) <span class="keyword">return</span> pHead1</span><br><span class="line">    <span class="keyword">if</span> (pHead1.val &lt; pHead2.val) &#123;</span><br><span class="line">        pHead1.next = Merge(pHead1.next, pHead2)</span><br><span class="line">        <span class="keyword">return</span> pHead1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pHead2.next = Merge(pHead1, pHead2.next)</span><br><span class="line">        <span class="keyword">return</span> pHead2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：采用非递归版本</strong><br>比较两个链表的首结点，哪个小的的结点则合并到第三个链表尾结点，并向前移动一个结点。<br>步骤一结果会有一个链表先遍历结束，或者没有<br>第三个链表尾结点指向剩余未遍历结束的链表<br>返回第三个链表首结点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Merge</span>(<span class="params">pHead1, pHead2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHead1) <span class="keyword">return</span> pHead2</span><br><span class="line">    <span class="keyword">if</span> (!pHead2) <span class="keyword">return</span> pHead1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> head</span><br><span class="line">    <span class="keyword">if</span> (pHead1.val &lt;= pHead2.val) &#123;</span><br><span class="line">        head = pHead1</span><br><span class="line">        pHead1 = pHead1.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = pHead2</span><br><span class="line">        pHead2 = pHead2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p = head</span><br><span class="line">    <span class="keyword">while</span> (pHead1 &amp;&amp; pHead2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1.val &lt;= pHead2.val) &#123;</span><br><span class="line">            p.next = pHead1</span><br><span class="line">            pHead1 = pHead1.next</span><br><span class="line">            p = p.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = pHead2</span><br><span class="line">            pHead2 = pHead2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!pHead1) p.next = pHead2</span><br><span class="line">    <span class="keyword">if</span> (!pHead2) p.next = pHead1</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>16 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function TreeNode(x) &#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.left = null;</span></span><br><span class="line"><span class="comment">    this.right = null;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure><p><strong>方法1</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HasSubtree</span>(<span class="params">pRoot1, pRoot2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">        <span class="comment">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot1 != <span class="literal">null</span> &amp;&amp; pRoot2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1.val === pRoot2.val) &#123;</span><br><span class="line">            <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">            flag = _hasSubtree(pRoot1, pRoot2)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            flag = HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            flag = HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断以node1为根的子树与以node2为根的子树是否完全相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_hasSubtree</span>(<span class="params">node1, node2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">    <span class="keyword">return</span> _hasSubtree(node1.left, node2.left) &amp;&amp; _hasSubtree(node1.right, node2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：使用短路版本进行改写，方法同上，只是简化了代码，但是测试不通过？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HasSubtree</span>(<span class="params">node1, node2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> _hasSubtree(node1, node2) ||</span><br><span class="line">        HasSubtree(node1.left, node2) ||</span><br><span class="line">        HasSubtree(node1.right, node2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_hasSubtree</span>(<span class="params">pRoot1, pRoot2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot1.val === pRoot2.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _hasSubtree(pRoot1.left, pRoot2.left) &amp;&amp; _hasSubtree(pRoot1.right, pRoot2.right)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>17 操作给定的二叉树，将其变换为源二叉树的镜像。</strong><br><strong>方法1:采用递归</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mirror</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> temp = root.left</span><br><span class="line">    root.left = root.right</span><br><span class="line">    root.right = temp</span><br><span class="line">    <span class="keyword">if</span> (root.left) &#123; Mirror(root.left) &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123; Mirror(root.right) &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>18 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尚未想到思路</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMatrix</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>19 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</strong><br><strong>分析：</strong><br>思路：利用一个辅助栈来存放最小值<br>​ 栈 3，4，2，5，1<br>​ 辅助栈 3，3，2，2，1<br>每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶<br>当出栈时，辅助栈也要出栈<br>这种做法可以保证辅助栈顶一定都当前栈的最小值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stack1 = [], <span class="comment">//主栈</span></span><br><span class="line">    stack2 = [] <span class="comment">//辅助栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    stack1.push(value)</span><br><span class="line">    <span class="keyword">if</span> (!stack2) &#123;</span><br><span class="line">        stack2.push(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt;= stack2.top()) &#123;</span><br><span class="line">        stack2.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack2.top() === stack1.top()) &#123;</span><br><span class="line">        stack2.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    stack1.pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">top</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack1[stack1.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack2[stack2.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>19 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。</strong><br><strong>分析：</strong><br>入栈1,2,3,4,5<br>出栈4,5,3,2,1<br>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，<br>然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，<br>所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，<br>如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p><p>测试未通过,why？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsPopOrder1</span>(<span class="params">pushV, popV</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!pushV) || (!popV)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pushV.length; i++) &#123;</span><br><span class="line">        stack.push(pushV[i])</span><br><span class="line">            <span class="comment">//如果栈不为空，且栈顶元素等于弹出序列</span></span><br><span class="line">        <span class="keyword">while</span> (stack.length !== <span class="number">0</span> &amp;&amp; stack[stack.length - <span class="number">1</span>] === popV[index]) &#123;</span><br><span class="line">            stack.pop()</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和以上解法一样，j相当于index</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsPopOrder2</span>(<span class="params">pushV, popV</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushV.length; i++) &#123;</span><br><span class="line">        list.push(pushV[i]);</span><br><span class="line">        <span class="keyword">while</span> (list.length !== <span class="number">0</span> &amp;&amp; list[list.length - <span class="number">1</span>] == popV[j]) &#123;</span><br><span class="line">            list.pop();</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.length === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>20 从上往下打印出二叉树的每个节点，同层节点从左至右打印。（层次遍历，借助队列实现）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function TreeNode(x) &#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.left = null;</span></span><br><span class="line"><span class="comment">    this.right = null;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintFromTopToBottom</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodes = [],</span><br><span class="line">        vals = []</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> vals</span><br><span class="line">    nodes.push(root)</span><br><span class="line">    <span class="keyword">while</span> (nodes.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = nodes.shift()</span><br><span class="line">        vals.push(cur.val)</span><br><span class="line">        <span class="keyword">if</span> (cur.left) &#123;</span><br><span class="line">            nodes.push(cur.left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right) &#123;</span><br><span class="line">            nodes.push(cur.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>21 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p><p><strong>思路：</strong><br>已知条件：后序序列最后一个值为root；二叉搜索树左子树值都比root小，右子树值都比root大。<br>1、确定root；<br>2、遍历序列（除去root结点），找到第一个大于root的位置，则该位置左边为左子树，右边为右子树；<br>3、遍历右子树，若发现有小于root的值，则直接返回false；<br>4、分别判断左子树和右子树是否仍是二叉搜索树（即递归步骤1、2、3）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VerifySquenceOfBST</span>(<span class="params">sequence</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = [],</span><br><span class="line">        right = []</span><br><span class="line">    <span class="keyword">let</span> root</span><br><span class="line">    <span class="keyword">if</span> (sequence.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> index <span class="comment">//左右子树界限</span></span><br><span class="line">    root = sequence[sequence.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; sequence.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &gt; root) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; sequence.length - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[j] &lt; root) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>; m &lt; i; m++)</span><br><span class="line">            left.push(sequence[m])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i !== sequence.length - <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>; m &lt; i; m++)</span><br><span class="line">            right.push(sequence[m])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> leftFlag = <span class="literal">true</span>,</span><br><span class="line">        rightFlag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (left.length &gt; <span class="number">1</span>) leftFlag = VerifySquenceOfBST(left)</span><br><span class="line">    <span class="keyword">if</span> (right.length &gt; <span class="number">1</span>) VerifySquenceOfBST(right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (leftFlag &amp;&amp; rightFlag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：</strong></p><p><strong>思路：找住二叉查找树的特点：左子树&lt;根&lt;=右子树 使用分治思想</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VerifySquenceOfBST</span>(<span class="params">sequence</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (sequence.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> _judge(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_judge</span>(<span class="params">a, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> i = start</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt; a[end]) &#123;</span><br><span class="line">        ++i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; end; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; a[end])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _judge(a, start, i - <span class="number">1</span>) &amp;&amp; _judge(a, i, end - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>22 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function TreeNode(x) &#123;</span></span><br><span class="line"><span class="comment">    this.va = x;</span></span><br><span class="line"><span class="comment">    this.left = null;</span></span><br><span class="line"><span class="comment">    this.right = null;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="comment">//可以使用递归解决，但是测试不通过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPath</span>(<span class="params">root, expectNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> listAll = [],</span><br><span class="line">        list = []</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> listAll</span><br><span class="line">    list.push(root.val)</span><br><span class="line">    expectNumber -= root.val</span><br><span class="line">    <span class="keyword">if</span> (expectNumber == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        listAll.push(list)</span><br><span class="line">    &#125;</span><br><span class="line">    FindPath(root.left, expectNumber)</span><br><span class="line">    FindPath(root.right, expectNumber)</span><br><span class="line">    list.pop()</span><br><span class="line">    <span class="keyword">return</span> listAll</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>23 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</strong></p><p>（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function RandomListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.label = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">    this.random = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//方法1:递归</span></span><br><span class="line"><span class="comment">//此题转化为一个头结点和除去头结点剩余部分，剩余部分操作和原问题一致</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clone</span>(<span class="params">pHead</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用new一个对象无法测试通过</span></span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> RandomListNode(pHead.x)</span><br><span class="line">    <span class="keyword">let</span> newNode = pHead</span><br><span class="line"></span><br><span class="line">    newNode.next = pHead.next</span><br><span class="line">    newNode.random = pHead.random</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始递归</span></span><br><span class="line">    newNode.next = Clone(pHead.next)</span><br><span class="line">    <span class="keyword">return</span> newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：三步走——无法测试通过</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clone</span>(<span class="params">pHead</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentNode = pHead;</span><br><span class="line">    <span class="comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneNode = currentNode;</span><br><span class="line">        <span class="keyword">let</span> nextNode = currentNode.next;</span><br><span class="line">        currentNode.next = cloneNode;</span><br><span class="line">        cloneNode.next = nextNode;</span><br><span class="line">        currentNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode = pHead;</span><br><span class="line">    <span class="comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        currentNode.next.random = currentNode.random == <span class="literal">null</span> ? <span class="literal">null</span> : currentNode.random.next;</span><br><span class="line">        currentNode = currentNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">    currentNode = pHead;</span><br><span class="line">    <span class="keyword">let</span> pCloneHead = pHead.next;</span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneNode = currentNode.next;</span><br><span class="line">        currentNode.next = cloneNode.next;</span><br><span class="line">        cloneNode.next = cloneNode.next == <span class="literal">null</span> ? <span class="literal">null</span> : cloneNode.next.next;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pCloneHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>24 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</strong></p><p><strong>方法1：非递归版</strong><br>解题思路：<br>1.核心是中序遍历的非递归算法。<br>2.修改当前遍历节点与前一遍历节点的指针指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Convert</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> p = root;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>; 用于保存中序遍历序列的上一节点</span><br><span class="line">    <span class="keyword">let</span> isFirst = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">            root = p; 将中序遍历序列中的第一个节点记为root</span><br><span class="line">            pre = root;</span><br><span class="line">            isFirst = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = p;</span><br><span class="line">            p.left = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：递归版</strong><br>解题思路：<br>1.将左子树构造成双链表，并返回链表头节点。<br>2.定位至左子树双链表最后一个节点。<br>3.如果左子树链表不为空的话，将当前root追加到左子树链表。<br>4.将右子树构造成双链表，并返回链表头节点。<br>5.如果右子树链表不为空的话，将该链表追加到root节点之后。<br>6.根据左子树链表是否为空确定返回的节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Convert</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="number">1.</span>将左子树构造成双链表，并返回链表头节点</span><br><span class="line">    <span class="keyword">let</span> left = Convert(root.left);</span><br><span class="line">    <span class="keyword">let</span> p = left;</span><br><span class="line">    <span class="number">2.</span>定位至左子树双链表最后一个节点</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">3.</span>如果左子树链表不为空的话，将当前root追加到左子树链表</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.right = root;</span><br><span class="line">        root.left = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">4.</span>将右子树构造成双链表，并返回链表头节点</span><br><span class="line">    <span class="keyword">let</span> right = Convert(root.right);</span><br><span class="line">    <span class="number">5.</span>如果右子树链表不为空的话，将该链表追加到root节点之后</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        right.left = root;</span><br><span class="line">        root.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：改进递归版</strong><br>解题思路：<br>思路与方法二中的递归版一致，仅对第2点中的定位作了修改，<br>新增一个全局变量记录左子树的最后一个节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Convert</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        leftLast = root; 最后的一个节点可能为最右侧的叶节点</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">1.</span>将左子树构造成双链表，并返回链表头节点</span><br><span class="line">    <span class="keyword">let</span> left = Convert(root.left);</span><br><span class="line">    <span class="number">3.</span>如果左子树链表不为空的话，将当前root追加到左子树链表</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftLast.right = root;</span><br><span class="line">        root.left = leftLast;</span><br><span class="line">    &#125;</span><br><span class="line">    leftLast = root; 当根节点只含左子树时，则该根节点为最后一个节点</span><br><span class="line">    <span class="number">4.</span>将右子树构造成双链表，并返回链表头节点</span><br><span class="line">    <span class="keyword">let</span> right = Convert(root.right);</span><br><span class="line">    <span class="number">5.</span>如果右子树链表不为空的话，将该链表追加到root节点之后</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        right.left = root;</span><br><span class="line">        root.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>25 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Permutation</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str !== <span class="string">''</span>) dfs(str, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_dfs</span>(<span class="params">str, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = str.length</span><br><span class="line">    <span class="keyword">if</span> (s === len) &#123;</span><br><span class="line">        result.push(str)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = s; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != s &amp;&amp; str[s] == str[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> temp = str[s]</span><br><span class="line">        str[s] = str[i]</span><br><span class="line">        str[i] = str[s]</span><br><span class="line">            [str[s], str[i]] = [str[i], str[s]]</span><br><span class="line">        dfs(str, s + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>26 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</strong></p><p><strong>方法1：快速排序</strong><br>先对这个数组进行排序，在已排序的数组中，位于中间位置的数字就是超过数组长度一半的那个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> left = [],</span><br><span class="line">        right = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] &lt;= pivot ? left.push(arr[i]) : right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _quickSort(left).concat([pivot], _quickSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MoreThanHalfNum_Solution1</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = numbers.length</span><br><span class="line">    <span class="keyword">let</span> sortedNumbers = _quickSort(numbers)</span><br><span class="line">    <span class="keyword">let</span> midNum = sortedNumbers[<span class="built_in">Math</span>.floor(len / <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sortedNumbers[i] === midNum) count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count * <span class="number">2</span> &gt; len) <span class="keyword">return</span> midNum</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：直接使用键值对存储数和出现的次数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MoreThanHalfNum_Solution2</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = numbers.length</span><br><span class="line">    <span class="keyword">let</span> json = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = numbers[i]</span><br><span class="line">        <span class="keyword">if</span> (json.hasOwnProperty(key)) &#123;</span><br><span class="line">            json[key]++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            json[key] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> json) &#123;</span><br><span class="line">        <span class="keyword">if</span> (json[key] * <span class="number">2</span> &gt; len) <span class="keyword">return</span> key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法3：依次循环，直接统计出出现最多的数字</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MoreThanHalfNum_Solution3</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = numbers.length</span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> num = numbers[<span class="number">0</span>],</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        numbers[i] == num ? count++ : count--</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                num = numbers[i]</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == num) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count * <span class="number">2</span> &gt; len) <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>26 输入n个整数，找出其中最小的K个数。</strong></p><p><strong>1)快排（针对找第k大的数，更快捷一些）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetLeastNumbers_Solution1</span>(<span class="params">input, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sorted = _quickSort(input)</span><br><span class="line">    <span class="keyword">return</span> sorted.slice(<span class="number">0</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）冒泡排序(测试不正确)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetLeastNumbers_Solution2</span>(<span class="params">input, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = input.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i + <span class="number">1</span>] &lt; input[i]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = input[i + <span class="number">1</span>]</span><br><span class="line">                input[i + <span class="number">1</span>] = input[i]</span><br><span class="line">                input[i] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input.slice(<span class="number">0</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>27 计算连续子向量的最大和（包括正数和负数）</strong></p><p>分析：使用动态规划<br>F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变<br>F（i）=max（F（i-1）+array[i],array[i]）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindGreatestSumOfSubArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> max = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max + array[i], array[i])</span><br><span class="line">        res = <span class="built_in">Math</span>.max(max, res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindGreatestSumOfSubArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!array) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> total = array[<span class="number">0</span>],</span><br><span class="line">        maxSum = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        total &gt;= <span class="number">0</span> ? total += array[i] : total = array[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> (total &gt; maxSum) maxSum = total</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>28 求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</strong></p><p>最直接的方法统计</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">        charLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = i.toString()</span><br><span class="line">        charLen = str.length</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; charLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[j] === <span class="string">'1'</span>)</span><br><span class="line">                count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = i</span><br><span class="line">        <span class="keyword">while</span> (i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp % <span class="number">10</span> === <span class="number">1</span>) count++</span><br><span class="line">                temp /= <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种解法？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>,</span><br><span class="line">        base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n / base) &#123;</span><br><span class="line">        <span class="keyword">let</span> bit = (n / base) - (n / base) / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>)</span><br><span class="line">            ret += n / (base * <span class="number">10</span>) * base;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">1</span>)</span><br><span class="line">            ret += n / (base * <span class="number">10</span>) * base + (n - n / base * base) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit &gt; <span class="number">1</span>)</span><br><span class="line">            ret += (n / (base * <span class="number">10</span>) + <span class="number">1</span>) * base;</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>29 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个.所以在这里自定义一个比较大小的函数，比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintMinNumber</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!numbers) <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">let</span> len = numbers.length</span><br><span class="line">    <span class="keyword">let</span> newArr = numbers.sort(_compare)</span><br><span class="line">    <span class="keyword">return</span> newArr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现自定义的排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_compare</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number1 = <span class="string">`<span class="subst">$&#123;n1&#125;</span><span class="subst">$&#123;n2&#125;</span>`</span></span><br><span class="line">    <span class="keyword">let</span> number2 = <span class="string">`<span class="subst">$&#123;n2&#125;</span><span class="subst">$&#123;n1&#125;</span>`</span></span><br><span class="line">    <span class="keyword">if</span> (number1 &gt; number2) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (number1 &lt; number2) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>30 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</strong></p><p><strong>思路解析：</strong><br>一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：<br>（1）丑数数组： 1<br>乘以2的队列：2<br>乘以3的队列：3<br>乘以5的队列：5<br>选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；<br>（2）丑数数组：1,2<br>乘以2的队列：4<br>乘以3的队列：3，6<br>乘以5的队列：5，10<br>选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；<br>（3）丑数数组：1,2,3<br>乘以2的队列：4,6<br>乘以3的队列：6,9<br>乘以5的队列：5,10,15<br>……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetUglyNumber_Solution</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">7</span>) <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> t2 = <span class="number">0</span>,</span><br><span class="line">        t3 = <span class="number">0</span>,</span><br><span class="line">        t5 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">        res[i] = <span class="built_in">Math</span>.min(res[t2] * <span class="number">2</span>, <span class="built_in">Math</span>.min(res[t3] * <span class="number">3</span>, res[t5] * <span class="number">5</span>));</span><br><span class="line">        <span class="keyword">if</span> (res[i] == res[t2] * <span class="number">2</span>) t2++;</span><br><span class="line">        <span class="keyword">if</span> (res[i] == res[t3] * <span class="number">3</span>) t3++;</span><br><span class="line">        <span class="keyword">if</span> (res[i] == res[t5] * <span class="number">5</span>) t5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[index - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>31 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</strong></p><p><strong>暴力搜索</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstNotRepeatingChar1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!count.hasOwnProperty(str[i])) &#123;</span><br><span class="line">            count[str[i]] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count[str[i]]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[str[i]] === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存在漏洞</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstNotRepeatingChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.lastIndexOf(str[i]) === i) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`只在<span class="subst">$&#123;i&#125;</span>位出现了<span class="subst">$&#123;str[i]&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> str[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>32 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</strong></p><p><strong>思路：参考《剑指offer》用归并排序的思想， 时间复杂度O(nlogn)</strong><br>function InversePairs(data) {<br>​ write code here<br>}</p><p><strong>33 输入两个链表，找出它们的第一个公共结点。</strong></p><p>/<em>function ListNode(x){<br>​ this.val = x;<br>​ this.next = null;<br>}</em>/<br><strong>思路：用两个指针扫描”两个链表“，最终两个指针到达 null 或者到达公共结点。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindFirstCommonNode</span>(<span class="params">pHead1, pHead2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = pHead1,</span><br><span class="line">        p2 = pHead2</span><br><span class="line">    <span class="keyword">while</span> (p1 !== p2) &#123;</span><br><span class="line">        p1 = (p1 == <span class="literal">null</span> ? pHead2 : p1.next)</span><br><span class="line">        p2 = (p2 == <span class="literal">null</span> ? pHead1 : p2.next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//思路与上述相同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindFirstCommonNode</span>(<span class="params">pHead1, pHead2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = pHead1;</span><br><span class="line">    <span class="keyword">let</span> p2 = pHead2;</span><br><span class="line">    <span class="keyword">while</span> (p1 !== p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span>) p1 = p1.next;</span><br><span class="line">        <span class="keyword">if</span> (p2 != <span class="literal">null</span>) p2 = p2.next;</span><br><span class="line">        <span class="keyword">if</span> (p1 != p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="literal">null</span>) p1 = pHead2;</span><br><span class="line">            <span class="keyword">if</span> (p2 == <span class="literal">null</span>) p2 = pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>34 统计一个数字在排序数组中出现的次数。</strong></p><p><strong>思路：由于数组有序，所以使用二分查找方法定位k的第一次出现位置和最后一次出现位置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetNumberOfK</span>(<span class="params">data, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> firstIndex = _getFirst(data, k)</span><br><span class="line">    <span class="keyword">let</span> lastIndex = _getLast(data, k)</span><br><span class="line">    <span class="keyword">return</span> lastIndex - firstIndex + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取k在data数组中第一次出现的index</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getFirst</span>(<span class="params">data, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">        end = data.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(start, end)</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[mid] &lt; k) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = <span class="built_in">Math</span>.floor(start, end)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取k在data数组中最后一次出现的index</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getLast</span>(<span class="params">data, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">        end = data.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(start, end)</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[mid] &lt;= k) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = <span class="built_in">Math</span>.floor(start, end)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>35 输入一棵二叉树，求该树的深度。</strong></p><p>**从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p>/* function TreeNode(x) {<br>​ this.val = x;<br>​ this.left = null;<br>​ this.right = null;<br>} <em>/<br>*</em>方法1：采用递归实现**</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeDepth</span>(<span class="params">pRoot</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(TreeDepth(pRoot.left) + <span class="number">1</span>, TreeDepth(pRoot.right) + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：非递归——层次遍历(测试未通过)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeDepth</span>(<span class="params">pRoot</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    queue.push(pRoot);</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span>,</span><br><span class="line">        count = <span class="number">0</span>,</span><br><span class="line">        nextCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> top = queue.pop();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (top.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.push(top.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.push(top.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == nextCount) &#123;</span><br><span class="line">            nextCount = queue.length;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试同样未通过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeDepth</span>(<span class="params">pRoot</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    queue.push(pRoot)</span><br><span class="line">    <span class="keyword">let</span> level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue) &#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length</span><br><span class="line">        level++</span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = queue[<span class="number">0</span>]</span><br><span class="line">            queue.pop()</span><br><span class="line">            <span class="keyword">if</span> (temp.left) queue.push(temp.left)</span><br><span class="line">            <span class="keyword">if</span> (temp.right) queue.push(temp.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>36 输入一棵二叉树，判断该二叉树是否是平衡二叉树。</strong></p><p><strong>方法1：利用剪枝</strong><br>改为从下往上遍历，如果子树是平衡二叉树，则返回子树的高度；如果发现子树不是平衡二叉树，<br>则直接停止遍历，这样至多只对每个结点访问一次。</p><p>测试未通过，请检查是否存在语法错误或者数组越界非法访问等情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsBalanced_Solution</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _getDepth(root) != <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> left = _getDepth(root.left)</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> right = _getDepth(root.right)</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span> + <span class="built_in">Math</span>.max(left, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：</strong><br>测试仍然未通过，请检查是否存在语法错误或者数组越界非法访问等情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isBalanced = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsBalanced_Solution</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    _getDepth(root);</span><br><span class="line">    <span class="keyword">return</span> isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = getDepth(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = getDepth(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        isBalanced = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right &gt; left ? right + <span class="number">1</span> : left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>37 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</strong></p><p>首先：位运算中异或的性质：两个相同数字异或=0，一个数和0异或还是它本身。<br>当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。<br>依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。<br>我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。<br>如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。<br>然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num1, num2</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        temp ^= array[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> indexOf1 = _findFirstBit(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_isBit(array[i], indexOf1))</span><br><span class="line">            num1 ^= array[i]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num2 ^= array[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [num1, num2]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到第一个为1的二进制位</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_findFirstBit</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> indexBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (indexBit) &lt; <span class="number">8</span> * <span class="number">4</span>) &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ++indexBit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexBit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断这个数第index位是否为1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_isBit</span>(<span class="params">num, indexBit</span>) </span>&#123;</span><br><span class="line">    num = num &gt;&gt; indexBit;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>38 有多少种连续的正数序列的和为sum(至少包括两个数)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindContinuousSequence</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">1</span>,</span><br><span class="line">        high = <span class="number">2</span></span><br><span class="line">        求和公式是(a0+an)*n/<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = (high + low) * (high - low + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            <span class="comment">//相等，那么就将窗口范围的所有数添加进结果集</span></span><br><span class="line">        <span class="keyword">if</span> (cur == sum) &#123;</span><br><span class="line">            <span class="keyword">let</span> list = []</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = low; i &lt;= high; i++)</span><br><span class="line">                list.push(i)</span><br><span class="line">            result.push(list)</span><br><span class="line">            low++</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; sum) &#123;</span><br><span class="line">            high++</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>39 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumbersWithSum</span>(<span class="params">array, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">let</span> len = array.length</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = len - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        找到的第一组（相差最大的）就是乘积最小的。</span><br><span class="line">        可以这样证明：考虑x+y=C（C是常数），x*y的大小。</span><br><span class="line">        不妨设y&gt;=x，y-x=d&gt;=<span class="number">0</span>，即y=x+d, <span class="number">2</span>x+d=C, x=(C-d)/<span class="number">2</span>, x*y=x(x+d)=(C-d)(C+d)/<span class="number">4</span>=(C^<span class="number">2</span>-d^<span class="number">2</span>)/<span class="number">4</span>，</span><br><span class="line">        也就是x*y是一个关于变量d的二次函数，对称轴是y轴，开口向下。</span><br><span class="line">        d是&gt;=<span class="number">0</span>的，d越大, x*y也就越小。</span><br><span class="line">        <span class="keyword">if</span> (array[i] + array[j] === sum) &#123;</span><br><span class="line">            res.push(array[i])</span><br><span class="line">            res.push(array[j])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] + array[j] &gt; sum) --j;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] + array[j] &lt; sum) ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>40 对于一个给定的字符序列S，请你把其循环左移K位后的序列输出</strong></p><p>提交未通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LeftRotateString1</span>(<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = str.length</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">    n = n % len</span><br><span class="line">    str += str</span><br><span class="line">    <span class="keyword">return</span> str.slice(n, n + len)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提交未通过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LeftRotateString2</span>(<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = str.length</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">let</span> s1 = str.slice(<span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">let</span> s2 = str.slice(n, len)</span><br><span class="line">    <span class="keyword">return</span> s2 + s1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地测试通过，但是提交不通过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LeftRotateString3</span>(<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = str.length</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> str</span><br><span class="line">    n = n % len</span><br><span class="line">    <span class="keyword">let</span> s1 = _reverse(str.slice(<span class="number">0</span>, n), <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> s2 = _reverse(str.slice(n, len), n, len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> res = _reverse(s1 + s2, <span class="number">0</span>, len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_reverse</span>(<span class="params">str, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[start]</span><br><span class="line">        arr[start] = arr[end]</span><br><span class="line">        arr[end] = temp</span><br><span class="line">        start++, end--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>41 单词顺序反转</strong></p><p>利用反转函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseSentence1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">' '</span>)</span><br><span class="line">    arr.reverse()</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用新数组存储反转单词</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseSentence2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.trim() == <span class="string">""</span>) <span class="keyword">return</span> str</span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">let</span> temp = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先反转整个句子，再依次反转每个单词</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseSentence3</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = str.length</span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">''</span>)</span><br><span class="line">        判断句子中是否含有<span class="string">' '</span>字符，如果没有，则为一个单词，不做处理直接返回即可</span><br><span class="line">    <span class="keyword">if</span> (arr.includes(<span class="string">' '</span>)) &#123;</span><br><span class="line">        _reverse(arr, <span class="number">0</span>, len - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> blank = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> nextBlank = i</span><br><span class="line">                _reverse(arr, blank + <span class="number">1</span>, nextBlank - <span class="number">1</span>);</span><br><span class="line">                blank = nextBlank;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _reverse(arr, blank + <span class="number">1</span>, len - <span class="number">1</span>) <span class="comment">//最后一个单词单独进行反转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_reverse</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[start]</span><br><span class="line">        arr[start] = arr[end]</span><br><span class="line">        arr[end] = temp</span><br><span class="line">        start++, end--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>42 有2个大王,2个小王(一副牌原本是54张)…</strong></p><p>随机从中抽出了5张牌，大\ 小 王可以看成任何数字, 并且A看作1, J为11, Q为12, K为13<br>求抽到顺子的概率<br>为了方便起见,你可以认为大小王是0。</p><p><strong>思路：</strong><br>满足条件：<br>1、max-min&lt;5<br>2、除0外没有重复的数字<br>3、数组长度为5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsContinuous</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> len = numbers.length,</span><br><span class="line">        max = <span class="number">-1</span>,</span><br><span class="line">        min = <span class="number">14</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map[numbers[i]]) &#123;</span><br><span class="line">            map[numbers[i]] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[numbers[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map[numbers[i]] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt; max) max = numbers[i]</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt; min) min = numbers[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max - min &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>43 随机指定一个数m,让编号为0的小朋友开始报数，小朋友的编号是从0到n-1.每次喊到m-1的那个小朋友要出列唱首歌并出列，再从下一个小朋友开始问最后留下的一个小朋友是谁？</strong></p><p>问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人 继续从0开始报数。求胜利者的编号。</p><p><strong>思路1：数学归纳法——不懂…</strong><br>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。<br>递推公式<br>f[1]=0;<br>f[i]=(f[i-1]+m)%i; (i&gt;1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LastRemaining_Solution</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2：用数组模拟环——不懂…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LastRemaining_Solution</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> array = []</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">-1</span>,</span><br><span class="line">        step = <span class="number">0</span>,</span><br><span class="line">        count = n</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i++; <span class="comment">//指向上一个被删除对象的下一个元素。</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= n) i = <span class="number">0</span>; <span class="comment">//模拟环。</span></span><br><span class="line">        <span class="keyword">if</span> (array[i] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//跳过被删除的对象。</span></span><br><span class="line">        step++; <span class="comment">//记录已走过的。</span></span><br><span class="line">        <span class="keyword">if</span> (step == m) &#123; <span class="comment">//找到待删除的对象。</span></span><br><span class="line">            array[i] = <span class="number">-1</span>;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">//返回跳出循环时的i,即最后一个被设置为-1的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>44 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</strong></p><p>共同点：一，利用利用短路 &amp;&amp; 来实现 if的功能；二，利用递归来实现循环while的功能<br>不同点：方法一：递归实现1+2+..+n;方法二：n(n+1)/2,递归实现n(n+1)；方法三，利用Math实现n(n+1)<br><strong>思路1：递归实现1+2+..+n</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum_Solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = n</span><br><span class="line">    <span class="keyword">let</span> temp = n &amp;&amp; Sum_Solution(n - <span class="number">1</span>)</span><br><span class="line">    result += temp</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2： n(n+1)/2,递归实现n(n+1)；</strong><br><strong>思路3，利用Math实现n(n+1)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum_Solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Math</span>.pow(n, <span class="number">2</span>) + n) &gt;&gt; <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>45 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</strong></p><p>首先看十进制是如何做的： 5+7=12，三步走<br>第一步：相加各位的值，不算进位，得到2。<br>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。<br>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。<br>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。<br>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = num1 ^ num2;</span><br><span class="line">        num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        num1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>46 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</strong></p><p>以下算法测试不通过，如输入+123,输出为0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StrToInt</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.trim() == <span class="string">''</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> symbol = <span class="number">1</span></span><br><span class="line">        判断正负号</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        symbol = <span class="number">-1</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">'0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        symbol = <span class="number">1</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">'0'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum * <span class="number">10</span> + <span class="built_in">parseInt</span>(str[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symbol * sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试通过！</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StrToInt2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> numlist = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'+'</span>, <span class="string">'-'</span>]</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>,</span><br><span class="line">        symbol = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">''</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numlist.includes(char)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (char == <span class="string">'+'</span>) &#123;</span><br><span class="line">                symbol = <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char == <span class="string">'-'</span>) &#123;</span><br><span class="line">                symbol = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = sum * <span class="number">10</span> + numlist.indexOf(char)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * symbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>47 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</strong></p><p><strong>思路1:</strong><br>最简单的方法：我最直接的想法就是构造一个容量为N的辅助数组B，原数组A中每个数对应B中下标，首次命中，B中对应元素+1。如果某次命中时，B中对应的不为0，<br>说明，前边已经有一样数字了，那它就是重复的了。</p><p>时间复杂度O（n），空间复杂度O（n），算法优点是简单快速，比用set更轻量更快，不打乱原数组顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span>(<span class="params">numbers, duplication</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment">//函数返回True/False</span></span><br><span class="line">    <span class="keyword">let</span> count = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[numbers[i]] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            count[numbers[i]] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间O(n)， 空间O(1)_这个看不太懂…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span>(<span class="params">numbers, duplication</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!numbers) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (numbers[i] !== i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>48 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</strong></p><p>参考<a href="https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    write code here</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(StrToInt2(<span class="string">'123'</span>))</span><br></pre></td></tr></table></figure></div><footer class="article-footer"><div class="post-share"><a href="javascript:;" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://localhost:4000/2019/04/08/剑指offer/&title=《剑指offer笔记》 — blog&pic=/images/banner.jpg" data-title="微博"><i class="fa fa-weibo"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信"><i class="fa fa-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://localhost:4000/2019/04/08/剑指offer/&title=《剑指offer笔记》 — blog&source=1 在一个二维数组中（每个一维数组的长度相同）,每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维..." data-title="QQ"><i class="fa fa-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2019/04/08/剑指offer/" data-title="Facebook"><i class="fa fa-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《剑指offer笔记》 — blog&url=http://localhost:4000/2019/04/08/剑指offer/&via=http://localhost:4000" data-title="Twitter"><i class="fa fa-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://localhost:4000/2019/04/08/剑指offer/" data-title="Google+"><i class="fa fa-google-plus"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:;" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=http://localhost:4000/2019/04/08/剑指offer/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"></ul></footer></div></article><nav id="article-nav"><a href="/2019/05/21/前端测试、性能监测、自动化集成方案/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title"><i class="fa fa-hand-o-left" aria-hidden="true"></i> 前端测试、性能监测、自动化集成方案 </span></a><a href="/2019/03/30/项目开发笔记/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">项目开发笔记</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MDE5Mi8yNjY4Mg=="><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a> &copy; 2020 Yang Pei<br></p></div></div></footer><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script>var mihoConfig={root:"http://localhost:4000",animate:"true",isHome:"false",share:"true"}</script><div class="sidebar"><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/AI/">AI</a><a class="category-link" href="/categories/CV/">CV</a><a class="category-link" href="/categories/ML/">ML</a><a class="category-link" href="/categories/NLP/">NLP</a><a class="category-link" href="/categories/专题/">专题</a><a class="category-link" href="/categories/前端/">前端</a><a class="category-link" href="/categories/感想/">感想</a><a class="category-link" href="/categories/源码/">源码</a><a class="category-link" href="/categories/计算机/">计算机</a><a class="category-link" href="/categories/语言/">语言</a></div><div id="sidebar-menu-box-tags"></div></div><a href="javascript:;" class="sidebar-menu-box-close">&times;</a></div>ß<div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">Menus</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/categories/前端/"><i class="fa fa-前端"></i><span>前端</span></a></li><li><a href="/categories/源码/"><i class="fa fa-源码"></i><span>源码</span></a></li><li><a href="/categories/ML/"><i class="fa fa-ML"></i><span>ML</span></a></li><li><a href="/categories/CV/"><i class="fa fa-CV"></i><span>CV</span></a></li><li><a href="/categories/NLP/"><i class="fa fa-NLP"></i><span>NLP</span></a></li><li><a href="/categories/计算机/"><i class="fa fa-计算机"></i><span>计算机</span></a></li><li><a href="/categories/专题/"><i class="fa fa-专题"></i><span>专题</span></a></li><li><a href="/categories/感想/"><i class="fa fa-感想"></i><span>感想</span></a></li><li><a href="/categories/语言/"><i class="fa fa-语言"></i><span>语言</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">Tags</span><div id="mobile-header-container-tags"></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:;"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script><script src="/js/pop-img.js"></script><script>$(".article-entry p img").popImg()</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/Epsilon2.1.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body>